<?xml version="1.0" encoding="utf-8"?>
<Technique>

	<Include System="Transformation"/>
	<Include System="Camera"/>

	<FrameBuffer System="Default"/>

	<Sampler Name="ConeTracingSampler">
		<State BorderColor="0, 0, 0, 0"/>
		<State AddressingModeR="ClampToBorder"/>
		<State AddressingModeS="ClampToBorder"/>
		<State AddressingModeT="ClampToBorder"/>
		<State MagFilterMode="Linear"/>
		<State MinFilterMode="LinearMipmapLinear"/>
	</Sampler>

	<Texture Name="voxels" TextureType="Texture3D" TexelType="FloatV4" Sampler="ConeTracingSampler"/>

	<UniformBuffer Name="NeverChanged">
		<Variable Name="voxelVolumeCenter" Type="FloatV3"/>
		<Variable Name="voxelVolumeHalfSize" Type="Float"/>
	</UniformBuffer>

	<UniformBuffer Name="TracingParameter">
		<Variable Name="aperture" Type="Float"/>
	</UniformBuffer>
	
	<AttributeInput Name="position" Type="FloatV3"/>

	<RasterizerState>
		<State CullMode="None"/>
	</RasterizerState>

	<DepthStencilState>
	</DepthStencilState>

	<BlendState>
		<State BlendEnable="true"/>
		<State BlendOperation="Add"/>
		<State BlendOperationAlpha="Add"/>
		<State SourceBlend="One"/>
		<State SourceBlendAlpha="SourceAlpha"/>
		<State DestinationBlend="OneMinusSourceAlpha"/>
		<State DestinationBlendAlpha="OneMinusSourceAlpha"/>
	</BlendState>
	
	<Code>
		<![CDATA[
uniform sampler3D voxels;

uniform NeverChanged
{
	vec3 voxelVolumeCenter;
	float voxelVolumeHalfSize;
};

uniform TracingParameter
{
	float aperture;
};
		]]>
	</Code>

	<VertexShader>
		<Code>
			<![CDATA[
in vec3 position; // [-1, 1], should be the back face of the bounding box.
out vec3 wPosition;

void main()
{
	wPosition = XREX_Transform(XREX_ModelTransformation.WorldFromModel, position);
	gl_Position = XREX_TransformToClip(XREX_ModelTransformation.ClipFromModel, position);
}
			]]>
		</Code>
	</VertexShader>

	<FragmentShader>
		<Code>
			<![CDATA[
/*
 *	@r: sample size over voxel size.
 */
vec4 AdjustResult(vec4 value, float r)
{
	if (value.a < 0.0001)
	{
		return value;
	}
 	float adjustedAlpha = 1 - pow(1 - value.a, r);
 	return value * adjustedAlpha / value.a;
}

const float ReciprocalLog2 = 1 / log(2);

/*
 *	@vexelVolume: voxels range from [-1, 1].
 *	@normalizedSamplePoint: should be normalized to [-1, 1].
 *	@normalizedSampleRadius: should be normalized to [0, 1].
 */
vec4 Sample(sampler3D vexelVolume, float voxelSize, vec3 normalizedSamplePoint, float normalizedSampleRadius)
{
	vec3 textureCoordinate = normalizedSamplePoint + vec3(1, 1, 1) / 2;
	float sampleSize = normalizedSampleRadius / 2 * 2; // sampleSize is diameter
	float sampleLevel = log(sampleSize / voxelSize) * ReciprocalLog2;
	vec4 result = textureLod(vexelVolume, textureCoordinate, max(0, sampleLevel));
	result = AdjustResult(result, sampleSize / voxelSize); // adjust result based on size difference
	return result;
}

/*
 *	Front to back accumulation.
 */
vec4 AccumulateColor(vec4 currentColor, vec4 newColor)
{
	return currentColor + (1 - currentColor.a) * newColor;
}

/*
 *	@vexelVolume: color should alpha pre-multiplied.
 *	@return: alpha pre-multiplied color.
 */
vec4 ConeTrace(sampler3D vexelVolume, vec3 volumeCenter, float volumeHalfSize, vec3 startPoint, vec3 viewDirection, float coneAperture, float alphaThreshold)
{
	const ivec3 gridCounts = textureSize(vexelVolume, 0); // x,y,z should be the same.
	const int gridCount = gridCounts.x;
	const float maxTracingDistance = volumeHalfSize * 4; // TODO change to proper value
	const float smallestGridSize = 2 * volumeHalfSize / gridCount;
	const float sinHalfAperture = sin(coneAperture / 2);

	vec4 finalColor = vec4(0, 0, 0, 0); // alpha pre-multiplied color

	// the volume of first sample point should include the startPoint
	float currentSampleDistance = smallestGridSize / 2;
	float currentSampleRadius = currentSampleDistance;

	while (currentSampleDistance + currentSampleRadius < maxTracingDistance)
	{
		vec3 currentSamplePoint = startPoint - volumeCenter + viewDirection * currentSampleDistance;
		vec4 color = Sample(vexelVolume, float(1) / gridCount, currentSamplePoint / volumeHalfSize, currentSampleRadius / volumeHalfSize); // normalized to [-1, 1]
		//vec4 modifiedColor = mix(vec4(0, 1, 0, color.a), vec4(0, 1, 1, color.a), currentSampleDistance / maxTracingDistance); // TODO temp
		//finalColor = AccumulateColor(finalColor, modifiedColor);
		finalColor = AccumulateColor(finalColor, color);
		if (finalColor.a > alphaThreshold)
		{
			break;
		}
		// next sphere inside the cone next to the current sample sphere.
		// (currentSampleDistance + currentSampleRadius + nextSampleRadius) * sin(sinHalfAperture) = nextSampleRadius
		float nextSampleRadius = (currentSampleDistance + currentSampleRadius) * sinHalfAperture / (1 - sinHalfAperture);
		float tracingStep = currentSampleRadius + nextSampleRadius;
		if (tracingStep < smallestGridSize) // make the tracingStep always larger than a voxel
		{
			tracingStep = smallestGridSize / 2;
			nextSampleRadius = tracingStep / 2;
		}
		currentSampleDistance = currentSampleDistance + tracingStep;
		currentSampleRadius = nextSampleRadius;
	}
	return finalColor;
}

			]]>
		</Code>
		<Code>
			<![CDATA[
const float alphaThreshold = 0.99;

in vec3 wPosition;

out vec4 XREX_DefaultFrameBufferOutput;

void main()
{
	vec3 direction = normalize(wPosition - XREX_CameraTransformation.CameraPositionInWorld);
	vec4 color = ConeTrace(voxels, voxelVolumeCenter, voxelVolumeHalfSize, XREX_CameraTransformation.CameraPositionInWorld, direction, aperture, alphaThreshold);
	XREX_DefaultFrameBufferOutput = color;
}
			]]>
		</Code>
	</FragmentShader>



</Technique>
